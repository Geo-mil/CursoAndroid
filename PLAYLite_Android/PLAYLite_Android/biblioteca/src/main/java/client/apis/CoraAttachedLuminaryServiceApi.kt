/**
 * PriluxWebUI API
 *
 * PriluxWebUI
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException

import org.openapitools.client.models.CoraAttachedLuminary
import org.openapitools.client.models.CoraAttachedLuminaryDto
import org.openapitools.client.models.CoraAttachedLuminaryDtoListResultDto
import org.openapitools.client.models.CoraAttachedLuminaryDtoPagedResultDto
import org.openapitools.client.models.CoraLuminaryImage
import org.openapitools.client.models.CoraLuminaryLine
import org.openapitools.client.models.CoraLuminaryLineDtoListResultDto
import org.openapitools.client.models.CoraSavingsResponse
import org.openapitools.client.models.LuminaryExtensionDataDto
import org.openapitools.client.models.UploadFileDto

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class CoraAttachedLuminaryServiceApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
    * 
    * 
    * @param luminaryId  (optional)
    * @param newLuminaryLineId  (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceChangeAttachedLuminaryLocationPost(luminaryId: kotlin.Int?, newLuminaryLineId: kotlin.Int?) : Unit {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceChangeAttachedLuminaryLocationPostWithHttpInfo(luminaryId = luminaryId, newLuminaryLineId = newLuminaryLineId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param luminaryId  (optional)
    * @param newLuminaryLineId  (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceChangeAttachedLuminaryLocationPostWithHttpInfo(luminaryId: kotlin.Int?, newLuminaryLineId: kotlin.Int?) : ApiResponse<Unit?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceChangeAttachedLuminaryLocationPostRequestConfig(luminaryId = luminaryId, newLuminaryLineId = newLuminaryLineId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceChangeAttachedLuminaryLocationPost
    *
    * @param luminaryId  (optional)
    * @param newLuminaryLineId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceChangeAttachedLuminaryLocationPostRequestConfig(luminaryId: kotlin.Int?, newLuminaryLineId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (luminaryId != null) {
                    put("luminaryId", listOf(luminaryId.toString()))
                }
                if (newLuminaryLineId != null) {
                    put("newLuminaryLineId", listOf(newLuminaryLineId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraAttachedLuminaryService/ChangeAttachedLuminaryLocation",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @param circuitId  (optional)
    * @return CoraLuminaryLine
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceCreateCoraLuminaryLinePost(coraId: kotlin.Int?, circuitId: kotlin.Int?) : CoraLuminaryLine {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceCreateCoraLuminaryLinePostWithHttpInfo(coraId = coraId, circuitId = circuitId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraLuminaryLine
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @param circuitId  (optional)
    * @return ApiResponse<CoraLuminaryLine?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceCreateCoraLuminaryLinePostWithHttpInfo(coraId: kotlin.Int?, circuitId: kotlin.Int?) : ApiResponse<CoraLuminaryLine?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceCreateCoraLuminaryLinePostRequestConfig(coraId = coraId, circuitId = circuitId)

        return request<Unit, CoraLuminaryLine>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceCreateCoraLuminaryLinePost
    *
    * @param coraId  (optional)
    * @param circuitId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceCreateCoraLuminaryLinePostRequestConfig(coraId: kotlin.Int?, circuitId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (coraId != null) {
                    put("coraId", listOf(coraId.toString()))
                }
                if (circuitId != null) {
                    put("circuitId", listOf(circuitId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraAttachedLuminaryService/CreateCoraLuminaryLine",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraAttachedLuminaryDto  (optional)
    * @return CoraAttachedLuminaryDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceCreatePost(coraAttachedLuminaryDto: CoraAttachedLuminaryDto?) : CoraAttachedLuminaryDto {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceCreatePostWithHttpInfo(coraAttachedLuminaryDto = coraAttachedLuminaryDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraAttachedLuminaryDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraAttachedLuminaryDto  (optional)
    * @return ApiResponse<CoraAttachedLuminaryDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceCreatePostWithHttpInfo(coraAttachedLuminaryDto: CoraAttachedLuminaryDto?) : ApiResponse<CoraAttachedLuminaryDto?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceCreatePostRequestConfig(coraAttachedLuminaryDto = coraAttachedLuminaryDto)

        return request<CoraAttachedLuminaryDto, CoraAttachedLuminaryDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceCreatePost
    *
    * @param coraAttachedLuminaryDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceCreatePostRequestConfig(coraAttachedLuminaryDto: CoraAttachedLuminaryDto?) : RequestConfig<CoraAttachedLuminaryDto> {
        val localVariableBody = coraAttachedLuminaryDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraAttachedLuminaryService/Create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param id  (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceDeleteDelete(id: kotlin.Int?) : Unit {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceDeleteDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param id  (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceDeleteDeleteWithHttpInfo(id: kotlin.Int?) : ApiResponse<Unit?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceDeleteDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceDeleteDelete
    *
    * @param id  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceDeleteDeleteRequestConfig(id: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("Id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/services/app/CoraAttachedLuminaryService/Delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param from  (optional)
    * @param to  (optional)
    * @return CoraSavingsResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsBetweenDatesGet(from: java.time.OffsetDateTime?, to: java.time.OffsetDateTime?) : CoraSavingsResponse {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsBetweenDatesGetWithHttpInfo(from = from, to = to)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraSavingsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param from  (optional)
    * @param to  (optional)
    * @return ApiResponse<CoraSavingsResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsBetweenDatesGetWithHttpInfo(from: java.time.OffsetDateTime?, to: java.time.OffsetDateTime?) : ApiResponse<CoraSavingsResponse?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsBetweenDatesGetRequestConfig(from = from, to = to)

        return request<Unit, CoraSavingsResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsBetweenDatesGet
    *
    * @param from  (optional)
    * @param to  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsBetweenDatesGetRequestConfig(from: java.time.OffsetDateTime?, to: java.time.OffsetDateTime?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (from != null) {
                    put("from", listOf(parseDateToQueryString(from)))
                }
                if (to != null) {
                    put("to", listOf(parseDateToQueryString(to)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/CoraAttachedLuminaryService/GetAllCorasSavingsBetweenDates",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @return CoraSavingsResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsGet() : CoraSavingsResponse {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraSavingsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @return ApiResponse<CoraSavingsResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsGetWithHttpInfo() : ApiResponse<CoraSavingsResponse?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsGetRequestConfig()

        return request<Unit, CoraSavingsResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsGet
    *
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceGetAllCorasSavingsGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/CoraAttachedLuminaryService/GetAllCorasSavings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param keyword  (optional)
    * @param skipCount  (optional)
    * @param maxResultCount  (optional)
    * @return CoraAttachedLuminaryDtoPagedResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetAllGet(keyword: kotlin.String?, skipCount: kotlin.Int?, maxResultCount: kotlin.Int?) : CoraAttachedLuminaryDtoPagedResultDto {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceGetAllGetWithHttpInfo(keyword = keyword, skipCount = skipCount, maxResultCount = maxResultCount)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraAttachedLuminaryDtoPagedResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param keyword  (optional)
    * @param skipCount  (optional)
    * @param maxResultCount  (optional)
    * @return ApiResponse<CoraAttachedLuminaryDtoPagedResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetAllGetWithHttpInfo(keyword: kotlin.String?, skipCount: kotlin.Int?, maxResultCount: kotlin.Int?) : ApiResponse<CoraAttachedLuminaryDtoPagedResultDto?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceGetAllGetRequestConfig(keyword = keyword, skipCount = skipCount, maxResultCount = maxResultCount)

        return request<Unit, CoraAttachedLuminaryDtoPagedResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceGetAllGet
    *
    * @param keyword  (optional)
    * @param skipCount  (optional)
    * @param maxResultCount  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceGetAllGetRequestConfig(keyword: kotlin.String?, skipCount: kotlin.Int?, maxResultCount: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (keyword != null) {
                    put("Keyword", listOf(keyword.toString()))
                }
                if (skipCount != null) {
                    put("SkipCount", listOf(skipCount.toString()))
                }
                if (maxResultCount != null) {
                    put("MaxResultCount", listOf(maxResultCount.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/CoraAttachedLuminaryService/GetAll",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @return CoraAttachedLuminaryDtoListResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminariesGet(coraId: kotlin.Int?) : CoraAttachedLuminaryDtoListResultDto {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminariesGetWithHttpInfo(coraId = coraId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraAttachedLuminaryDtoListResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @return ApiResponse<CoraAttachedLuminaryDtoListResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminariesGetWithHttpInfo(coraId: kotlin.Int?) : ApiResponse<CoraAttachedLuminaryDtoListResultDto?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminariesGetRequestConfig(coraId = coraId)

        return request<Unit, CoraAttachedLuminaryDtoListResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminariesGet
    *
    * @param coraId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminariesGetRequestConfig(coraId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (coraId != null) {
                    put("CoraId", listOf(coraId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/CoraAttachedLuminaryService/GetCoraLuminaries",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @return CoraLuminaryLineDtoListResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminaryLinesGet(coraId: kotlin.Int?) : CoraLuminaryLineDtoListResultDto {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminaryLinesGetWithHttpInfo(coraId = coraId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraLuminaryLineDtoListResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @return ApiResponse<CoraLuminaryLineDtoListResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminaryLinesGetWithHttpInfo(coraId: kotlin.Int?) : ApiResponse<CoraLuminaryLineDtoListResultDto?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminaryLinesGetRequestConfig(coraId = coraId)

        return request<Unit, CoraLuminaryLineDtoListResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminaryLinesGet
    *
    * @param coraId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceGetCoraLuminaryLinesGetRequestConfig(coraId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (coraId != null) {
                    put("CoraId", listOf(coraId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/CoraAttachedLuminaryService/GetCoraLuminaryLines",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @return CoraSavingsResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetCoraSavingsGet(coraId: kotlin.Int?) : CoraSavingsResponse {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceGetCoraSavingsGetWithHttpInfo(coraId = coraId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraSavingsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @return ApiResponse<CoraSavingsResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetCoraSavingsGetWithHttpInfo(coraId: kotlin.Int?) : ApiResponse<CoraSavingsResponse?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceGetCoraSavingsGetRequestConfig(coraId = coraId)

        return request<Unit, CoraSavingsResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceGetCoraSavingsGet
    *
    * @param coraId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceGetCoraSavingsGetRequestConfig(coraId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (coraId != null) {
                    put("CoraId", listOf(coraId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/CoraAttachedLuminaryService/GetCoraSavings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param id  (optional)
    * @return CoraAttachedLuminaryDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetGet(id: kotlin.Int?) : CoraAttachedLuminaryDto {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceGetGetWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraAttachedLuminaryDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param id  (optional)
    * @return ApiResponse<CoraAttachedLuminaryDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetGetWithHttpInfo(id: kotlin.Int?) : ApiResponse<CoraAttachedLuminaryDto?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceGetGetRequestConfig(id = id)

        return request<Unit, CoraAttachedLuminaryDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceGetGet
    *
    * @param id  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceGetGetRequestConfig(id: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("Id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/CoraAttachedLuminaryService/Get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param lat1  (optional)
    * @param lon1  (optional)
    * @param lat2  (optional)
    * @param lon2  (optional)
    * @return CoraAttachedLuminaryDtoListResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetLuminariesByLocationGet(lat1: kotlin.Double?, lon1: kotlin.Double?, lat2: kotlin.Double?, lon2: kotlin.Double?) : CoraAttachedLuminaryDtoListResultDto {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceGetLuminariesByLocationGetWithHttpInfo(lat1 = lat1, lon1 = lon1, lat2 = lat2, lon2 = lon2)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraAttachedLuminaryDtoListResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param lat1  (optional)
    * @param lon1  (optional)
    * @param lat2  (optional)
    * @param lon2  (optional)
    * @return ApiResponse<CoraAttachedLuminaryDtoListResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceGetLuminariesByLocationGetWithHttpInfo(lat1: kotlin.Double?, lon1: kotlin.Double?, lat2: kotlin.Double?, lon2: kotlin.Double?) : ApiResponse<CoraAttachedLuminaryDtoListResultDto?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceGetLuminariesByLocationGetRequestConfig(lat1 = lat1, lon1 = lon1, lat2 = lat2, lon2 = lon2)

        return request<Unit, CoraAttachedLuminaryDtoListResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceGetLuminariesByLocationGet
    *
    * @param lat1  (optional)
    * @param lon1  (optional)
    * @param lat2  (optional)
    * @param lon2  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceGetLuminariesByLocationGetRequestConfig(lat1: kotlin.Double?, lon1: kotlin.Double?, lat2: kotlin.Double?, lon2: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (lat1 != null) {
                    put("lat1", listOf(lat1.toString()))
                }
                if (lon1 != null) {
                    put("lon1", listOf(lon1.toString()))
                }
                if (lat2 != null) {
                    put("lat2", listOf(lat2.toString()))
                }
                if (lon2 != null) {
                    put("lon2", listOf(lon2.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/CoraAttachedLuminaryService/GetLuminariesByLocation",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param luminaryId  (optional)
    * @param luminaryExtensionDataDto  (optional)
    * @return CoraAttachedLuminary
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceUpdateLuminaryExtensionDataPut(luminaryId: kotlin.Int?, luminaryExtensionDataDto: LuminaryExtensionDataDto?) : CoraAttachedLuminary {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceUpdateLuminaryExtensionDataPutWithHttpInfo(luminaryId = luminaryId, luminaryExtensionDataDto = luminaryExtensionDataDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraAttachedLuminary
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param luminaryId  (optional)
    * @param luminaryExtensionDataDto  (optional)
    * @return ApiResponse<CoraAttachedLuminary?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceUpdateLuminaryExtensionDataPutWithHttpInfo(luminaryId: kotlin.Int?, luminaryExtensionDataDto: LuminaryExtensionDataDto?) : ApiResponse<CoraAttachedLuminary?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceUpdateLuminaryExtensionDataPutRequestConfig(luminaryId = luminaryId, luminaryExtensionDataDto = luminaryExtensionDataDto)

        return request<LuminaryExtensionDataDto, CoraAttachedLuminary>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceUpdateLuminaryExtensionDataPut
    *
    * @param luminaryId  (optional)
    * @param luminaryExtensionDataDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceUpdateLuminaryExtensionDataPutRequestConfig(luminaryId: kotlin.Int?, luminaryExtensionDataDto: LuminaryExtensionDataDto?) : RequestConfig<LuminaryExtensionDataDto> {
        val localVariableBody = luminaryExtensionDataDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (luminaryId != null) {
                    put("luminaryId", listOf(luminaryId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/services/app/CoraAttachedLuminaryService/UpdateLuminaryExtensionData",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraAttachedLuminaryDto  (optional)
    * @return CoraAttachedLuminaryDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceUpdatePut(coraAttachedLuminaryDto: CoraAttachedLuminaryDto?) : CoraAttachedLuminaryDto {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceUpdatePutWithHttpInfo(coraAttachedLuminaryDto = coraAttachedLuminaryDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraAttachedLuminaryDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraAttachedLuminaryDto  (optional)
    * @return ApiResponse<CoraAttachedLuminaryDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceUpdatePutWithHttpInfo(coraAttachedLuminaryDto: CoraAttachedLuminaryDto?) : ApiResponse<CoraAttachedLuminaryDto?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceUpdatePutRequestConfig(coraAttachedLuminaryDto = coraAttachedLuminaryDto)

        return request<CoraAttachedLuminaryDto, CoraAttachedLuminaryDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceUpdatePut
    *
    * @param coraAttachedLuminaryDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceUpdatePutRequestConfig(coraAttachedLuminaryDto: CoraAttachedLuminaryDto?) : RequestConfig<CoraAttachedLuminaryDto> {
        val localVariableBody = coraAttachedLuminaryDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/services/app/CoraAttachedLuminaryService/Update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param luminaryId  (optional)
    * @param uploadFileDto  (optional)
    * @return CoraLuminaryImage
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceUploadLuminaryImagePost(luminaryId: kotlin.Int?, uploadFileDto: UploadFileDto?) : CoraLuminaryImage {
        val localVarResponse = apiServicesAppCoraAttachedLuminaryServiceUploadLuminaryImagePostWithHttpInfo(luminaryId = luminaryId, uploadFileDto = uploadFileDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraLuminaryImage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param luminaryId  (optional)
    * @param uploadFileDto  (optional)
    * @return ApiResponse<CoraLuminaryImage?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraAttachedLuminaryServiceUploadLuminaryImagePostWithHttpInfo(luminaryId: kotlin.Int?, uploadFileDto: UploadFileDto?) : ApiResponse<CoraLuminaryImage?> {
        val localVariableConfig = apiServicesAppCoraAttachedLuminaryServiceUploadLuminaryImagePostRequestConfig(luminaryId = luminaryId, uploadFileDto = uploadFileDto)

        return request<UploadFileDto, CoraLuminaryImage>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraAttachedLuminaryServiceUploadLuminaryImagePost
    *
    * @param luminaryId  (optional)
    * @param uploadFileDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraAttachedLuminaryServiceUploadLuminaryImagePostRequestConfig(luminaryId: kotlin.Int?, uploadFileDto: UploadFileDto?) : RequestConfig<UploadFileDto> {
        val localVariableBody = uploadFileDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (luminaryId != null) {
                    put("luminaryId", listOf(luminaryId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraAttachedLuminaryService/UploadLuminaryImage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
