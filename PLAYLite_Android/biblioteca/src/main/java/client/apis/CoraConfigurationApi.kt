/**
 * PriluxWebUI API
 *
 * PriluxWebUI
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException

import org.openapitools.client.models.CMRModeEnableDto
import org.openapitools.client.models.CoraAdvancedStatusInfoDto
import org.openapitools.client.models.CoraAstronomicalClockConfigureDto
import org.openapitools.client.models.CoraBoolErrorResponseDto
import org.openapitools.client.models.CoraCircuitEnableDto
import org.openapitools.client.models.CoraFirmwareUpdateJobDto
import org.openapitools.client.models.CoraFirmwareUpgradeAvailableVersionsDtoListResultDto
import org.openapitools.client.models.CoraImportDataWrapper
import org.openapitools.client.models.CoraResetCommandDto
import org.openapitools.client.models.CoraSequenceDto
import org.openapitools.client.models.MaintenanceModeManagementDto

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class CoraConfigurationApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
    * 
    * 
    * @param coraAstronomicalClockConfigureDto  (optional)
    * @return CoraBoolErrorResponseDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationCoonfigureAstronomicalClockPost(coraAstronomicalClockConfigureDto: CoraAstronomicalClockConfigureDto?) : CoraBoolErrorResponseDto {
        val localVarResponse = apiServicesAppCoraConfigurationCoonfigureAstronomicalClockPostWithHttpInfo(coraAstronomicalClockConfigureDto = coraAstronomicalClockConfigureDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraBoolErrorResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraAstronomicalClockConfigureDto  (optional)
    * @return ApiResponse<CoraBoolErrorResponseDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationCoonfigureAstronomicalClockPostWithHttpInfo(coraAstronomicalClockConfigureDto: CoraAstronomicalClockConfigureDto?) : ApiResponse<CoraBoolErrorResponseDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationCoonfigureAstronomicalClockPostRequestConfig(coraAstronomicalClockConfigureDto = coraAstronomicalClockConfigureDto)

        return request<CoraAstronomicalClockConfigureDto, CoraBoolErrorResponseDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationCoonfigureAstronomicalClockPost
    *
    * @param coraAstronomicalClockConfigureDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationCoonfigureAstronomicalClockPostRequestConfig(coraAstronomicalClockConfigureDto: CoraAstronomicalClockConfigureDto?) : RequestConfig<CoraAstronomicalClockConfigureDto> {
        val localVariableBody = coraAstronomicalClockConfigureDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraConfiguration/CoonfigureAstronomicalClock",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @param enabled  (optional)
    * @return CoraBoolErrorResponseDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationCoraSetMaintenanceModePost(coraId: kotlin.Int?, enabled: kotlin.Boolean?) : CoraBoolErrorResponseDto {
        val localVarResponse = apiServicesAppCoraConfigurationCoraSetMaintenanceModePostWithHttpInfo(coraId = coraId, enabled = enabled)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraBoolErrorResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @param enabled  (optional)
    * @return ApiResponse<CoraBoolErrorResponseDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationCoraSetMaintenanceModePostWithHttpInfo(coraId: kotlin.Int?, enabled: kotlin.Boolean?) : ApiResponse<CoraBoolErrorResponseDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationCoraSetMaintenanceModePostRequestConfig(coraId = coraId, enabled = enabled)

        return request<Unit, CoraBoolErrorResponseDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationCoraSetMaintenanceModePost
    *
    * @param coraId  (optional)
    * @param enabled  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationCoraSetMaintenanceModePostRequestConfig(coraId: kotlin.Int?, enabled: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (coraId != null) {
                    put("coraId", listOf(coraId.toString()))
                }
                if (enabled != null) {
                    put("enabled", listOf(enabled.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraConfiguration/CoraSetMaintenanceMode",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param maintenanceModeManagementDto  (optional)
    * @return CoraBoolErrorResponseDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationCreateMaintenanceModeJobPost(maintenanceModeManagementDto: MaintenanceModeManagementDto?) : CoraBoolErrorResponseDto {
        val localVarResponse = apiServicesAppCoraConfigurationCreateMaintenanceModeJobPostWithHttpInfo(maintenanceModeManagementDto = maintenanceModeManagementDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraBoolErrorResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param maintenanceModeManagementDto  (optional)
    * @return ApiResponse<CoraBoolErrorResponseDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationCreateMaintenanceModeJobPostWithHttpInfo(maintenanceModeManagementDto: MaintenanceModeManagementDto?) : ApiResponse<CoraBoolErrorResponseDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationCreateMaintenanceModeJobPostRequestConfig(maintenanceModeManagementDto = maintenanceModeManagementDto)

        return request<MaintenanceModeManagementDto, CoraBoolErrorResponseDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationCreateMaintenanceModeJobPost
    *
    * @param maintenanceModeManagementDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationCreateMaintenanceModeJobPostRequestConfig(maintenanceModeManagementDto: MaintenanceModeManagementDto?) : RequestConfig<MaintenanceModeManagementDto> {
        val localVariableBody = maintenanceModeManagementDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraConfiguration/CreateMaintenanceModeJob",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param cmRModeEnableDto  (optional)
    * @return CoraBoolErrorResponseDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationEnableCMRModeCoraPost(cmRModeEnableDto: CMRModeEnableDto?) : CoraBoolErrorResponseDto {
        val localVarResponse = apiServicesAppCoraConfigurationEnableCMRModeCoraPostWithHttpInfo(cmRModeEnableDto = cmRModeEnableDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraBoolErrorResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param cmRModeEnableDto  (optional)
    * @return ApiResponse<CoraBoolErrorResponseDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationEnableCMRModeCoraPostWithHttpInfo(cmRModeEnableDto: CMRModeEnableDto?) : ApiResponse<CoraBoolErrorResponseDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationEnableCMRModeCoraPostRequestConfig(cmRModeEnableDto = cmRModeEnableDto)

        return request<CMRModeEnableDto, CoraBoolErrorResponseDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationEnableCMRModeCoraPost
    *
    * @param cmRModeEnableDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationEnableCMRModeCoraPostRequestConfig(cmRModeEnableDto: CMRModeEnableDto?) : RequestConfig<CMRModeEnableDto> {
        val localVariableBody = cmRModeEnableDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraConfiguration/EnableCMRModeCora",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraCircuitEnableDto  (optional)
    * @return CoraBoolErrorResponseDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationEnableCircuitsCoraPost(coraCircuitEnableDto: CoraCircuitEnableDto?) : CoraBoolErrorResponseDto {
        val localVarResponse = apiServicesAppCoraConfigurationEnableCircuitsCoraPostWithHttpInfo(coraCircuitEnableDto = coraCircuitEnableDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraBoolErrorResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraCircuitEnableDto  (optional)
    * @return ApiResponse<CoraBoolErrorResponseDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationEnableCircuitsCoraPostWithHttpInfo(coraCircuitEnableDto: CoraCircuitEnableDto?) : ApiResponse<CoraBoolErrorResponseDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationEnableCircuitsCoraPostRequestConfig(coraCircuitEnableDto = coraCircuitEnableDto)

        return request<CoraCircuitEnableDto, CoraBoolErrorResponseDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationEnableCircuitsCoraPost
    *
    * @param coraCircuitEnableDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationEnableCircuitsCoraPostRequestConfig(coraCircuitEnableDto: CoraCircuitEnableDto?) : RequestConfig<CoraCircuitEnableDto> {
        val localVariableBody = coraCircuitEnableDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraConfiguration/EnableCircuitsCora",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @return CoraAdvancedStatusInfoDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationGetCoraAdvancedStatusInfoGet(coraId: kotlin.Int?) : CoraAdvancedStatusInfoDto {
        val localVarResponse = apiServicesAppCoraConfigurationGetCoraAdvancedStatusInfoGetWithHttpInfo(coraId = coraId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraAdvancedStatusInfoDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraId  (optional)
    * @return ApiResponse<CoraAdvancedStatusInfoDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationGetCoraAdvancedStatusInfoGetWithHttpInfo(coraId: kotlin.Int?) : ApiResponse<CoraAdvancedStatusInfoDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationGetCoraAdvancedStatusInfoGetRequestConfig(coraId = coraId)

        return request<Unit, CoraAdvancedStatusInfoDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationGetCoraAdvancedStatusInfoGet
    *
    * @param coraId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationGetCoraAdvancedStatusInfoGetRequestConfig(coraId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (coraId != null) {
                    put("CoraId", listOf(coraId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/CoraConfiguration/GetCoraAdvancedStatusInfo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @return CoraFirmwareUpgradeAvailableVersionsDtoListResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationGetCoraFirmwareAvailableUpdatesGet() : CoraFirmwareUpgradeAvailableVersionsDtoListResultDto {
        val localVarResponse = apiServicesAppCoraConfigurationGetCoraFirmwareAvailableUpdatesGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraFirmwareUpgradeAvailableVersionsDtoListResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @return ApiResponse<CoraFirmwareUpgradeAvailableVersionsDtoListResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationGetCoraFirmwareAvailableUpdatesGetWithHttpInfo() : ApiResponse<CoraFirmwareUpgradeAvailableVersionsDtoListResultDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationGetCoraFirmwareAvailableUpdatesGetRequestConfig()

        return request<Unit, CoraFirmwareUpgradeAvailableVersionsDtoListResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationGetCoraFirmwareAvailableUpdatesGet
    *
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationGetCoraFirmwareAvailableUpdatesGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/CoraConfiguration/GetCoraFirmwareAvailableUpdates",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraImportDataWrapper  (optional)
    * @return CoraBoolErrorResponseDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationImportCoraAndLuminariesDataPost(coraImportDataWrapper: CoraImportDataWrapper?) : CoraBoolErrorResponseDto {
        val localVarResponse = apiServicesAppCoraConfigurationImportCoraAndLuminariesDataPostWithHttpInfo(coraImportDataWrapper = coraImportDataWrapper)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraBoolErrorResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraImportDataWrapper  (optional)
    * @return ApiResponse<CoraBoolErrorResponseDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationImportCoraAndLuminariesDataPostWithHttpInfo(coraImportDataWrapper: CoraImportDataWrapper?) : ApiResponse<CoraBoolErrorResponseDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationImportCoraAndLuminariesDataPostRequestConfig(coraImportDataWrapper = coraImportDataWrapper)

        return request<CoraImportDataWrapper, CoraBoolErrorResponseDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationImportCoraAndLuminariesDataPost
    *
    * @param coraImportDataWrapper  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationImportCoraAndLuminariesDataPostRequestConfig(coraImportDataWrapper: CoraImportDataWrapper?) : RequestConfig<CoraImportDataWrapper> {
        val localVariableBody = coraImportDataWrapper
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraConfiguration/ImportCoraAndLuminariesData",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraResetCommandDto  (optional)
    * @return CoraBoolErrorResponseDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationResetCommandPost(coraResetCommandDto: CoraResetCommandDto?) : CoraBoolErrorResponseDto {
        val localVarResponse = apiServicesAppCoraConfigurationResetCommandPostWithHttpInfo(coraResetCommandDto = coraResetCommandDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraBoolErrorResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraResetCommandDto  (optional)
    * @return ApiResponse<CoraBoolErrorResponseDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationResetCommandPostWithHttpInfo(coraResetCommandDto: CoraResetCommandDto?) : ApiResponse<CoraBoolErrorResponseDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationResetCommandPostRequestConfig(coraResetCommandDto = coraResetCommandDto)

        return request<CoraResetCommandDto, CoraBoolErrorResponseDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationResetCommandPost
    *
    * @param coraResetCommandDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationResetCommandPostRequestConfig(coraResetCommandDto: CoraResetCommandDto?) : RequestConfig<CoraResetCommandDto> {
        val localVariableBody = coraResetCommandDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraConfiguration/ResetCommand",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraid  (optional)
    * @param circuitselection  (optional)
    * @param coraSequenceDto  (optional)
    * @return CoraBoolErrorResponseDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationSaveLastCoraSequencePost(coraid: kotlin.Int?, circuitselection: kotlin.Int?, coraSequenceDto: CoraSequenceDto?) : CoraBoolErrorResponseDto {
        val localVarResponse = apiServicesAppCoraConfigurationSaveLastCoraSequencePostWithHttpInfo(coraid = coraid, circuitselection = circuitselection, coraSequenceDto = coraSequenceDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraBoolErrorResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraid  (optional)
    * @param circuitselection  (optional)
    * @param coraSequenceDto  (optional)
    * @return ApiResponse<CoraBoolErrorResponseDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationSaveLastCoraSequencePostWithHttpInfo(coraid: kotlin.Int?, circuitselection: kotlin.Int?, coraSequenceDto: CoraSequenceDto?) : ApiResponse<CoraBoolErrorResponseDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationSaveLastCoraSequencePostRequestConfig(coraid = coraid, circuitselection = circuitselection, coraSequenceDto = coraSequenceDto)

        return request<CoraSequenceDto, CoraBoolErrorResponseDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationSaveLastCoraSequencePost
    *
    * @param coraid  (optional)
    * @param circuitselection  (optional)
    * @param coraSequenceDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationSaveLastCoraSequencePostRequestConfig(coraid: kotlin.Int?, circuitselection: kotlin.Int?, coraSequenceDto: CoraSequenceDto?) : RequestConfig<CoraSequenceDto> {
        val localVariableBody = coraSequenceDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (coraid != null) {
                    put("coraid", listOf(coraid.toString()))
                }
                if (circuitselection != null) {
                    put("circuitselection", listOf(circuitselection.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraConfiguration/SaveLastCoraSequence",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param coraFirmwareUpdateJobDto  (optional)
    * @return CoraBoolErrorResponseDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppCoraConfigurationUpgradeCoraFirmwarePost(coraFirmwareUpdateJobDto: CoraFirmwareUpdateJobDto?) : CoraBoolErrorResponseDto {
        val localVarResponse = apiServicesAppCoraConfigurationUpgradeCoraFirmwarePostWithHttpInfo(coraFirmwareUpdateJobDto = coraFirmwareUpdateJobDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoraBoolErrorResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param coraFirmwareUpdateJobDto  (optional)
    * @return ApiResponse<CoraBoolErrorResponseDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppCoraConfigurationUpgradeCoraFirmwarePostWithHttpInfo(coraFirmwareUpdateJobDto: CoraFirmwareUpdateJobDto?) : ApiResponse<CoraBoolErrorResponseDto?> {
        val localVariableConfig = apiServicesAppCoraConfigurationUpgradeCoraFirmwarePostRequestConfig(coraFirmwareUpdateJobDto = coraFirmwareUpdateJobDto)

        return request<CoraFirmwareUpdateJobDto, CoraBoolErrorResponseDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppCoraConfigurationUpgradeCoraFirmwarePost
    *
    * @param coraFirmwareUpdateJobDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppCoraConfigurationUpgradeCoraFirmwarePostRequestConfig(coraFirmwareUpdateJobDto: CoraFirmwareUpdateJobDto?) : RequestConfig<CoraFirmwareUpdateJobDto> {
        val localVariableBody = coraFirmwareUpdateJobDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/CoraConfiguration/UpgradeCoraFirmware",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
