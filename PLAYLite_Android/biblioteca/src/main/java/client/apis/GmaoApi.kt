/**
 * PriluxWebUI API
 *
 * PriluxWebUI
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException

import org.openapitools.client.models.ChangeCorrectiveMaintenanceStatusDto
import org.openapitools.client.models.ChangePreventiveMaintenanceStatusDto
import org.openapitools.client.models.CorrectiveMaintenanceStatus
import org.openapitools.client.models.CreateCorrectiveMaintenanceUpdateDto
import org.openapitools.client.models.CreateCorrectiveMaintenanceUpdateDtoListResultDto
import org.openapitools.client.models.CreateCorrectiveMaintenanceparentDto
import org.openapitools.client.models.CreateCorrectiveMaintenanceparentDtoListResultDto
import org.openapitools.client.models.CreateCorrectiveMaintenanceparentDtoPagedResultDto
import org.openapitools.client.models.CreatePreventiveMaintenanceConfigDto
import org.openapitools.client.models.CreatePreventiveMaintenanceConfigDtoListResultDto
import org.openapitools.client.models.CreatePreventiveMaintenanceConfigDtoPagedResultDto
import org.openapitools.client.models.CreatePreventiveMaintenanceParentDto
import org.openapitools.client.models.CreatePreventiveMaintenanceParentDtoListResultDto
import org.openapitools.client.models.CreatePreventiveMaintenanceUpdateDto
import org.openapitools.client.models.CreatePreventiveMaintenanceUpdateDtoListResultDto
import org.openapitools.client.models.GetImageUrlOutputDto
import org.openapitools.client.models.PreventiveMaintenanceStatus
import org.openapitools.client.models.UploadFileDto
import org.openapitools.client.models.UploadFileResponseDto

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class GmaoApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
    * 
    * 
    * @param changeCorrectiveMaintenanceStatusDto  (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoChangeCorrectiveMaintenanceStatusPost(changeCorrectiveMaintenanceStatusDto: ChangeCorrectiveMaintenanceStatusDto?) : Unit {
        val localVarResponse = apiServicesAppGmaoChangeCorrectiveMaintenanceStatusPostWithHttpInfo(changeCorrectiveMaintenanceStatusDto = changeCorrectiveMaintenanceStatusDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param changeCorrectiveMaintenanceStatusDto  (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoChangeCorrectiveMaintenanceStatusPostWithHttpInfo(changeCorrectiveMaintenanceStatusDto: ChangeCorrectiveMaintenanceStatusDto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiServicesAppGmaoChangeCorrectiveMaintenanceStatusPostRequestConfig(changeCorrectiveMaintenanceStatusDto = changeCorrectiveMaintenanceStatusDto)

        return request<ChangeCorrectiveMaintenanceStatusDto, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoChangeCorrectiveMaintenanceStatusPost
    *
    * @param changeCorrectiveMaintenanceStatusDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoChangeCorrectiveMaintenanceStatusPostRequestConfig(changeCorrectiveMaintenanceStatusDto: ChangeCorrectiveMaintenanceStatusDto?) : RequestConfig<ChangeCorrectiveMaintenanceStatusDto> {
        val localVariableBody = changeCorrectiveMaintenanceStatusDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/Gmao/ChangeCorrectiveMaintenanceStatus",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param changePreventiveMaintenanceStatusDto  (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoChangePreventiveMaintenanceStatusPost(changePreventiveMaintenanceStatusDto: ChangePreventiveMaintenanceStatusDto?) : Unit {
        val localVarResponse = apiServicesAppGmaoChangePreventiveMaintenanceStatusPostWithHttpInfo(changePreventiveMaintenanceStatusDto = changePreventiveMaintenanceStatusDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param changePreventiveMaintenanceStatusDto  (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoChangePreventiveMaintenanceStatusPostWithHttpInfo(changePreventiveMaintenanceStatusDto: ChangePreventiveMaintenanceStatusDto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiServicesAppGmaoChangePreventiveMaintenanceStatusPostRequestConfig(changePreventiveMaintenanceStatusDto = changePreventiveMaintenanceStatusDto)

        return request<ChangePreventiveMaintenanceStatusDto, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoChangePreventiveMaintenanceStatusPost
    *
    * @param changePreventiveMaintenanceStatusDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoChangePreventiveMaintenanceStatusPostRequestConfig(changePreventiveMaintenanceStatusDto: ChangePreventiveMaintenanceStatusDto?) : RequestConfig<ChangePreventiveMaintenanceStatusDto> {
        val localVariableBody = changePreventiveMaintenanceStatusDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/Gmao/ChangePreventiveMaintenanceStatus",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param createCorrectiveMaintenanceparentDto  (optional)
    * @return CreateCorrectiveMaintenanceparentDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoCreateCorrectiveMaintenanceParentPost(createCorrectiveMaintenanceparentDto: CreateCorrectiveMaintenanceparentDto?) : CreateCorrectiveMaintenanceparentDto {
        val localVarResponse = apiServicesAppGmaoCreateCorrectiveMaintenanceParentPostWithHttpInfo(createCorrectiveMaintenanceparentDto = createCorrectiveMaintenanceparentDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateCorrectiveMaintenanceparentDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param createCorrectiveMaintenanceparentDto  (optional)
    * @return ApiResponse<CreateCorrectiveMaintenanceparentDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoCreateCorrectiveMaintenanceParentPostWithHttpInfo(createCorrectiveMaintenanceparentDto: CreateCorrectiveMaintenanceparentDto?) : ApiResponse<CreateCorrectiveMaintenanceparentDto?> {
        val localVariableConfig = apiServicesAppGmaoCreateCorrectiveMaintenanceParentPostRequestConfig(createCorrectiveMaintenanceparentDto = createCorrectiveMaintenanceparentDto)

        return request<CreateCorrectiveMaintenanceparentDto, CreateCorrectiveMaintenanceparentDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoCreateCorrectiveMaintenanceParentPost
    *
    * @param createCorrectiveMaintenanceparentDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoCreateCorrectiveMaintenanceParentPostRequestConfig(createCorrectiveMaintenanceparentDto: CreateCorrectiveMaintenanceparentDto?) : RequestConfig<CreateCorrectiveMaintenanceparentDto> {
        val localVariableBody = createCorrectiveMaintenanceparentDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/Gmao/CreateCorrectiveMaintenanceParent",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param createCorrectiveMaintenanceUpdateDto  (optional)
    * @return CreateCorrectiveMaintenanceUpdateDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoCreateCorrectiveMaintenanceUpdatePost(createCorrectiveMaintenanceUpdateDto: CreateCorrectiveMaintenanceUpdateDto?) : CreateCorrectiveMaintenanceUpdateDto {
        val localVarResponse = apiServicesAppGmaoCreateCorrectiveMaintenanceUpdatePostWithHttpInfo(createCorrectiveMaintenanceUpdateDto = createCorrectiveMaintenanceUpdateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateCorrectiveMaintenanceUpdateDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param createCorrectiveMaintenanceUpdateDto  (optional)
    * @return ApiResponse<CreateCorrectiveMaintenanceUpdateDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoCreateCorrectiveMaintenanceUpdatePostWithHttpInfo(createCorrectiveMaintenanceUpdateDto: CreateCorrectiveMaintenanceUpdateDto?) : ApiResponse<CreateCorrectiveMaintenanceUpdateDto?> {
        val localVariableConfig = apiServicesAppGmaoCreateCorrectiveMaintenanceUpdatePostRequestConfig(createCorrectiveMaintenanceUpdateDto = createCorrectiveMaintenanceUpdateDto)

        return request<CreateCorrectiveMaintenanceUpdateDto, CreateCorrectiveMaintenanceUpdateDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoCreateCorrectiveMaintenanceUpdatePost
    *
    * @param createCorrectiveMaintenanceUpdateDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoCreateCorrectiveMaintenanceUpdatePostRequestConfig(createCorrectiveMaintenanceUpdateDto: CreateCorrectiveMaintenanceUpdateDto?) : RequestConfig<CreateCorrectiveMaintenanceUpdateDto> {
        val localVariableBody = createCorrectiveMaintenanceUpdateDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/Gmao/CreateCorrectiveMaintenanceUpdate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param createPreventiveMaintenanceConfigDto  (optional)
    * @return CreatePreventiveMaintenanceConfigDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoCreatePreventiveMaintenanceConfigPost(createPreventiveMaintenanceConfigDto: CreatePreventiveMaintenanceConfigDto?) : CreatePreventiveMaintenanceConfigDto {
        val localVarResponse = apiServicesAppGmaoCreatePreventiveMaintenanceConfigPostWithHttpInfo(createPreventiveMaintenanceConfigDto = createPreventiveMaintenanceConfigDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePreventiveMaintenanceConfigDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param createPreventiveMaintenanceConfigDto  (optional)
    * @return ApiResponse<CreatePreventiveMaintenanceConfigDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoCreatePreventiveMaintenanceConfigPostWithHttpInfo(createPreventiveMaintenanceConfigDto: CreatePreventiveMaintenanceConfigDto?) : ApiResponse<CreatePreventiveMaintenanceConfigDto?> {
        val localVariableConfig = apiServicesAppGmaoCreatePreventiveMaintenanceConfigPostRequestConfig(createPreventiveMaintenanceConfigDto = createPreventiveMaintenanceConfigDto)

        return request<CreatePreventiveMaintenanceConfigDto, CreatePreventiveMaintenanceConfigDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoCreatePreventiveMaintenanceConfigPost
    *
    * @param createPreventiveMaintenanceConfigDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoCreatePreventiveMaintenanceConfigPostRequestConfig(createPreventiveMaintenanceConfigDto: CreatePreventiveMaintenanceConfigDto?) : RequestConfig<CreatePreventiveMaintenanceConfigDto> {
        val localVariableBody = createPreventiveMaintenanceConfigDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/Gmao/CreatePreventiveMaintenanceConfig",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param createPreventiveMaintenanceParentDto  (optional)
    * @return CreatePreventiveMaintenanceParentDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoCreatePreventiveMaintenanceParentPost(createPreventiveMaintenanceParentDto: CreatePreventiveMaintenanceParentDto?) : CreatePreventiveMaintenanceParentDto {
        val localVarResponse = apiServicesAppGmaoCreatePreventiveMaintenanceParentPostWithHttpInfo(createPreventiveMaintenanceParentDto = createPreventiveMaintenanceParentDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePreventiveMaintenanceParentDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param createPreventiveMaintenanceParentDto  (optional)
    * @return ApiResponse<CreatePreventiveMaintenanceParentDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoCreatePreventiveMaintenanceParentPostWithHttpInfo(createPreventiveMaintenanceParentDto: CreatePreventiveMaintenanceParentDto?) : ApiResponse<CreatePreventiveMaintenanceParentDto?> {
        val localVariableConfig = apiServicesAppGmaoCreatePreventiveMaintenanceParentPostRequestConfig(createPreventiveMaintenanceParentDto = createPreventiveMaintenanceParentDto)

        return request<CreatePreventiveMaintenanceParentDto, CreatePreventiveMaintenanceParentDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoCreatePreventiveMaintenanceParentPost
    *
    * @param createPreventiveMaintenanceParentDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoCreatePreventiveMaintenanceParentPostRequestConfig(createPreventiveMaintenanceParentDto: CreatePreventiveMaintenanceParentDto?) : RequestConfig<CreatePreventiveMaintenanceParentDto> {
        val localVariableBody = createPreventiveMaintenanceParentDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/Gmao/CreatePreventiveMaintenanceParent",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param createPreventiveMaintenanceUpdateDto  (optional)
    * @return CreatePreventiveMaintenanceUpdateDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoCreatePreventiveMaintenanceUpdatePost(createPreventiveMaintenanceUpdateDto: CreatePreventiveMaintenanceUpdateDto?) : CreatePreventiveMaintenanceUpdateDto {
        val localVarResponse = apiServicesAppGmaoCreatePreventiveMaintenanceUpdatePostWithHttpInfo(createPreventiveMaintenanceUpdateDto = createPreventiveMaintenanceUpdateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePreventiveMaintenanceUpdateDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param createPreventiveMaintenanceUpdateDto  (optional)
    * @return ApiResponse<CreatePreventiveMaintenanceUpdateDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoCreatePreventiveMaintenanceUpdatePostWithHttpInfo(createPreventiveMaintenanceUpdateDto: CreatePreventiveMaintenanceUpdateDto?) : ApiResponse<CreatePreventiveMaintenanceUpdateDto?> {
        val localVariableConfig = apiServicesAppGmaoCreatePreventiveMaintenanceUpdatePostRequestConfig(createPreventiveMaintenanceUpdateDto = createPreventiveMaintenanceUpdateDto)

        return request<CreatePreventiveMaintenanceUpdateDto, CreatePreventiveMaintenanceUpdateDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoCreatePreventiveMaintenanceUpdatePost
    *
    * @param createPreventiveMaintenanceUpdateDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoCreatePreventiveMaintenanceUpdatePostRequestConfig(createPreventiveMaintenanceUpdateDto: CreatePreventiveMaintenanceUpdateDto?) : RequestConfig<CreatePreventiveMaintenanceUpdateDto> {
        val localVariableBody = createPreventiveMaintenanceUpdateDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/Gmao/CreatePreventiveMaintenanceUpdate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param correctiveMaintenanceId  (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoDeleteCorrectivemaintenanceDelete(correctiveMaintenanceId: kotlin.Int?) : Unit {
        val localVarResponse = apiServicesAppGmaoDeleteCorrectivemaintenanceDeleteWithHttpInfo(correctiveMaintenanceId = correctiveMaintenanceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param correctiveMaintenanceId  (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoDeleteCorrectivemaintenanceDeleteWithHttpInfo(correctiveMaintenanceId: kotlin.Int?) : ApiResponse<Unit?> {
        val localVariableConfig = apiServicesAppGmaoDeleteCorrectivemaintenanceDeleteRequestConfig(correctiveMaintenanceId = correctiveMaintenanceId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoDeleteCorrectivemaintenanceDelete
    *
    * @param correctiveMaintenanceId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoDeleteCorrectivemaintenanceDeleteRequestConfig(correctiveMaintenanceId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (correctiveMaintenanceId != null) {
                    put("correctiveMaintenanceId", listOf(correctiveMaintenanceId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/services/app/Gmao/DeleteCorrectivemaintenance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param preventiveMaintenanceConfigId  (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoDeletePreventiveMaintenanceConfigDelete(preventiveMaintenanceConfigId: kotlin.Int?) : Unit {
        val localVarResponse = apiServicesAppGmaoDeletePreventiveMaintenanceConfigDeleteWithHttpInfo(preventiveMaintenanceConfigId = preventiveMaintenanceConfigId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param preventiveMaintenanceConfigId  (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoDeletePreventiveMaintenanceConfigDeleteWithHttpInfo(preventiveMaintenanceConfigId: kotlin.Int?) : ApiResponse<Unit?> {
        val localVariableConfig = apiServicesAppGmaoDeletePreventiveMaintenanceConfigDeleteRequestConfig(preventiveMaintenanceConfigId = preventiveMaintenanceConfigId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoDeletePreventiveMaintenanceConfigDelete
    *
    * @param preventiveMaintenanceConfigId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoDeletePreventiveMaintenanceConfigDeleteRequestConfig(preventiveMaintenanceConfigId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (preventiveMaintenanceConfigId != null) {
                    put("preventiveMaintenanceConfigId", listOf(preventiveMaintenanceConfigId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/services/app/Gmao/DeletePreventiveMaintenanceConfig",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param preventiveMaintenanceId  (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoDeletePreventiveMaintenanceDelete(preventiveMaintenanceId: kotlin.Int?) : Unit {
        val localVarResponse = apiServicesAppGmaoDeletePreventiveMaintenanceDeleteWithHttpInfo(preventiveMaintenanceId = preventiveMaintenanceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param preventiveMaintenanceId  (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoDeletePreventiveMaintenanceDeleteWithHttpInfo(preventiveMaintenanceId: kotlin.Int?) : ApiResponse<Unit?> {
        val localVariableConfig = apiServicesAppGmaoDeletePreventiveMaintenanceDeleteRequestConfig(preventiveMaintenanceId = preventiveMaintenanceId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoDeletePreventiveMaintenanceDelete
    *
    * @param preventiveMaintenanceId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoDeletePreventiveMaintenanceDeleteRequestConfig(preventiveMaintenanceId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (preventiveMaintenanceId != null) {
                    put("preventiveMaintenanceId", listOf(preventiveMaintenanceId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/services/app/Gmao/DeletePreventiveMaintenance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param parentMaintenanceId  (optional)
    * @return CreateCorrectiveMaintenanceUpdateDtoListResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoGetCorrectiveMaintenanceUpdatesGet(parentMaintenanceId: kotlin.Int?) : CreateCorrectiveMaintenanceUpdateDtoListResultDto {
        val localVarResponse = apiServicesAppGmaoGetCorrectiveMaintenanceUpdatesGetWithHttpInfo(parentMaintenanceId = parentMaintenanceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateCorrectiveMaintenanceUpdateDtoListResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param parentMaintenanceId  (optional)
    * @return ApiResponse<CreateCorrectiveMaintenanceUpdateDtoListResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoGetCorrectiveMaintenanceUpdatesGetWithHttpInfo(parentMaintenanceId: kotlin.Int?) : ApiResponse<CreateCorrectiveMaintenanceUpdateDtoListResultDto?> {
        val localVariableConfig = apiServicesAppGmaoGetCorrectiveMaintenanceUpdatesGetRequestConfig(parentMaintenanceId = parentMaintenanceId)

        return request<Unit, CreateCorrectiveMaintenanceUpdateDtoListResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoGetCorrectiveMaintenanceUpdatesGet
    *
    * @param parentMaintenanceId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoGetCorrectiveMaintenanceUpdatesGetRequestConfig(parentMaintenanceId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (parentMaintenanceId != null) {
                    put("parentMaintenanceId", listOf(parentMaintenanceId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/Gmao/GetCorrectiveMaintenanceUpdates",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param from  
    * @param to  
    * @return CreateCorrectiveMaintenanceparentDtoListResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoGetCorrectiveMaintenancesByDatesGet(from: java.time.OffsetDateTime, to: java.time.OffsetDateTime) : CreateCorrectiveMaintenanceparentDtoListResultDto {
        val localVarResponse = apiServicesAppGmaoGetCorrectiveMaintenancesByDatesGetWithHttpInfo(from = from, to = to)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateCorrectiveMaintenanceparentDtoListResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param from  
    * @param to  
    * @return ApiResponse<CreateCorrectiveMaintenanceparentDtoListResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoGetCorrectiveMaintenancesByDatesGetWithHttpInfo(from: java.time.OffsetDateTime, to: java.time.OffsetDateTime) : ApiResponse<CreateCorrectiveMaintenanceparentDtoListResultDto?> {
        val localVariableConfig = apiServicesAppGmaoGetCorrectiveMaintenancesByDatesGetRequestConfig(from = from, to = to)

        return request<Unit, CreateCorrectiveMaintenanceparentDtoListResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoGetCorrectiveMaintenancesByDatesGet
    *
    * @param from  
    * @param to  
    * @return RequestConfig
    */
    fun apiServicesAppGmaoGetCorrectiveMaintenancesByDatesGetRequestConfig(from: java.time.OffsetDateTime, to: java.time.OffsetDateTime) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("From", listOf(parseDateToQueryString(from)))
                put("To", listOf(parseDateToQueryString(to)))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/Gmao/GetCorrectiveMaintenancesByDates",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param status  (optional)
    * @param keyword  (optional)
    * @param skipCount  (optional)
    * @param maxResultCount  (optional)
    * @return CreateCorrectiveMaintenanceparentDtoPagedResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoGetCorrectiveMaintenancesGet(status: CorrectiveMaintenanceStatus?, keyword: kotlin.String?, skipCount: kotlin.Int?, maxResultCount: kotlin.Int?) : CreateCorrectiveMaintenanceparentDtoPagedResultDto {
        val localVarResponse = apiServicesAppGmaoGetCorrectiveMaintenancesGetWithHttpInfo(status = status, keyword = keyword, skipCount = skipCount, maxResultCount = maxResultCount)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateCorrectiveMaintenanceparentDtoPagedResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param status  (optional)
    * @param keyword  (optional)
    * @param skipCount  (optional)
    * @param maxResultCount  (optional)
    * @return ApiResponse<CreateCorrectiveMaintenanceparentDtoPagedResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoGetCorrectiveMaintenancesGetWithHttpInfo(status: CorrectiveMaintenanceStatus?, keyword: kotlin.String?, skipCount: kotlin.Int?, maxResultCount: kotlin.Int?) : ApiResponse<CreateCorrectiveMaintenanceparentDtoPagedResultDto?> {
        val localVariableConfig = apiServicesAppGmaoGetCorrectiveMaintenancesGetRequestConfig(status = status, keyword = keyword, skipCount = skipCount, maxResultCount = maxResultCount)

        return request<Unit, CreateCorrectiveMaintenanceparentDtoPagedResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoGetCorrectiveMaintenancesGet
    *
    * @param status  (optional)
    * @param keyword  (optional)
    * @param skipCount  (optional)
    * @param maxResultCount  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoGetCorrectiveMaintenancesGetRequestConfig(status: CorrectiveMaintenanceStatus?, keyword: kotlin.String?, skipCount: kotlin.Int?, maxResultCount: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (status != null) {
                    put("Status", listOf(status.toString()))
                }
                if (keyword != null) {
                    put("Keyword", listOf(keyword.toString()))
                }
                if (skipCount != null) {
                    put("SkipCount", listOf(skipCount.toString()))
                }
                if (maxResultCount != null) {
                    put("MaxResultCount", listOf(maxResultCount.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/Gmao/GetCorrectiveMaintenances",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param fileIds  (optional)
    * @return GetImageUrlOutputDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoGetImageUrlGet(fileIds: kotlin.collections.List<kotlin.Int>?) : GetImageUrlOutputDto {
        val localVarResponse = apiServicesAppGmaoGetImageUrlGetWithHttpInfo(fileIds = fileIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetImageUrlOutputDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param fileIds  (optional)
    * @return ApiResponse<GetImageUrlOutputDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoGetImageUrlGetWithHttpInfo(fileIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<GetImageUrlOutputDto?> {
        val localVariableConfig = apiServicesAppGmaoGetImageUrlGetRequestConfig(fileIds = fileIds)

        return request<Unit, GetImageUrlOutputDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoGetImageUrlGet
    *
    * @param fileIds  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoGetImageUrlGetRequestConfig(fileIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fileIds != null) {
                    put("FileIds", toMultiValue(fileIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/Gmao/GetImageUrl",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param days  (optional)
    * @return CreatePreventiveMaintenanceConfigDtoListResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoGetPreventiveMaintenaceConfigToProcessBySchedulerGet(days: kotlin.Int?) : CreatePreventiveMaintenanceConfigDtoListResultDto {
        val localVarResponse = apiServicesAppGmaoGetPreventiveMaintenaceConfigToProcessBySchedulerGetWithHttpInfo(days = days)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePreventiveMaintenanceConfigDtoListResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param days  (optional)
    * @return ApiResponse<CreatePreventiveMaintenanceConfigDtoListResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoGetPreventiveMaintenaceConfigToProcessBySchedulerGetWithHttpInfo(days: kotlin.Int?) : ApiResponse<CreatePreventiveMaintenanceConfigDtoListResultDto?> {
        val localVariableConfig = apiServicesAppGmaoGetPreventiveMaintenaceConfigToProcessBySchedulerGetRequestConfig(days = days)

        return request<Unit, CreatePreventiveMaintenanceConfigDtoListResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoGetPreventiveMaintenaceConfigToProcessBySchedulerGet
    *
    * @param days  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoGetPreventiveMaintenaceConfigToProcessBySchedulerGetRequestConfig(days: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (days != null) {
                    put("days", listOf(days.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/Gmao/GetPreventiveMaintenaceConfigToProcessByScheduler",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param maxResultCount  (optional)
    * @param skipCount  (optional)
    * @return CreatePreventiveMaintenanceConfigDtoPagedResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoGetPreventiveMaintenanceConfigsGet(maxResultCount: kotlin.Int?, skipCount: kotlin.Int?) : CreatePreventiveMaintenanceConfigDtoPagedResultDto {
        val localVarResponse = apiServicesAppGmaoGetPreventiveMaintenanceConfigsGetWithHttpInfo(maxResultCount = maxResultCount, skipCount = skipCount)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePreventiveMaintenanceConfigDtoPagedResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param maxResultCount  (optional)
    * @param skipCount  (optional)
    * @return ApiResponse<CreatePreventiveMaintenanceConfigDtoPagedResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoGetPreventiveMaintenanceConfigsGetWithHttpInfo(maxResultCount: kotlin.Int?, skipCount: kotlin.Int?) : ApiResponse<CreatePreventiveMaintenanceConfigDtoPagedResultDto?> {
        val localVariableConfig = apiServicesAppGmaoGetPreventiveMaintenanceConfigsGetRequestConfig(maxResultCount = maxResultCount, skipCount = skipCount)

        return request<Unit, CreatePreventiveMaintenanceConfigDtoPagedResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoGetPreventiveMaintenanceConfigsGet
    *
    * @param maxResultCount  (optional)
    * @param skipCount  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoGetPreventiveMaintenanceConfigsGetRequestConfig(maxResultCount: kotlin.Int?, skipCount: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResultCount != null) {
                    put("MaxResultCount", listOf(maxResultCount.toString()))
                }
                if (skipCount != null) {
                    put("SkipCount", listOf(skipCount.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/Gmao/GetPreventiveMaintenanceConfigs",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param preventiveMaintenanceId  (optional)
    * @return CreatePreventiveMaintenanceUpdateDtoListResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoGetPreventiveMaintenanceUpdatesGet(preventiveMaintenanceId: kotlin.Int?) : CreatePreventiveMaintenanceUpdateDtoListResultDto {
        val localVarResponse = apiServicesAppGmaoGetPreventiveMaintenanceUpdatesGetWithHttpInfo(preventiveMaintenanceId = preventiveMaintenanceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePreventiveMaintenanceUpdateDtoListResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param preventiveMaintenanceId  (optional)
    * @return ApiResponse<CreatePreventiveMaintenanceUpdateDtoListResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoGetPreventiveMaintenanceUpdatesGetWithHttpInfo(preventiveMaintenanceId: kotlin.Int?) : ApiResponse<CreatePreventiveMaintenanceUpdateDtoListResultDto?> {
        val localVariableConfig = apiServicesAppGmaoGetPreventiveMaintenanceUpdatesGetRequestConfig(preventiveMaintenanceId = preventiveMaintenanceId)

        return request<Unit, CreatePreventiveMaintenanceUpdateDtoListResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoGetPreventiveMaintenanceUpdatesGet
    *
    * @param preventiveMaintenanceId  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoGetPreventiveMaintenanceUpdatesGetRequestConfig(preventiveMaintenanceId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (preventiveMaintenanceId != null) {
                    put("preventiveMaintenanceId", listOf(preventiveMaintenanceId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/Gmao/GetPreventiveMaintenanceUpdates",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param from  
    * @param to  
    * @return CreatePreventiveMaintenanceParentDtoListResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoGetPreventiveMaintenancesByDatesGet(from: java.time.OffsetDateTime, to: java.time.OffsetDateTime) : CreatePreventiveMaintenanceParentDtoListResultDto {
        val localVarResponse = apiServicesAppGmaoGetPreventiveMaintenancesByDatesGetWithHttpInfo(from = from, to = to)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePreventiveMaintenanceParentDtoListResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param from  
    * @param to  
    * @return ApiResponse<CreatePreventiveMaintenanceParentDtoListResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoGetPreventiveMaintenancesByDatesGetWithHttpInfo(from: java.time.OffsetDateTime, to: java.time.OffsetDateTime) : ApiResponse<CreatePreventiveMaintenanceParentDtoListResultDto?> {
        val localVariableConfig = apiServicesAppGmaoGetPreventiveMaintenancesByDatesGetRequestConfig(from = from, to = to)

        return request<Unit, CreatePreventiveMaintenanceParentDtoListResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoGetPreventiveMaintenancesByDatesGet
    *
    * @param from  
    * @param to  
    * @return RequestConfig
    */
    fun apiServicesAppGmaoGetPreventiveMaintenancesByDatesGetRequestConfig(from: java.time.OffsetDateTime, to: java.time.OffsetDateTime) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("From", listOf(parseDateToQueryString(from)))
                put("To", listOf(parseDateToQueryString(to)))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/Gmao/GetPreventiveMaintenancesByDates",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param status  (optional)
    * @param skipCount  (optional)
    * @param maxResultCount  (optional)
    * @return CreatePreventiveMaintenanceParentDtoListResultDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoGetPreventiveMaintenancesGet(status: PreventiveMaintenanceStatus?, skipCount: kotlin.Int?, maxResultCount: kotlin.Int?) : CreatePreventiveMaintenanceParentDtoListResultDto {
        val localVarResponse = apiServicesAppGmaoGetPreventiveMaintenancesGetWithHttpInfo(status = status, skipCount = skipCount, maxResultCount = maxResultCount)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePreventiveMaintenanceParentDtoListResultDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param status  (optional)
    * @param skipCount  (optional)
    * @param maxResultCount  (optional)
    * @return ApiResponse<CreatePreventiveMaintenanceParentDtoListResultDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoGetPreventiveMaintenancesGetWithHttpInfo(status: PreventiveMaintenanceStatus?, skipCount: kotlin.Int?, maxResultCount: kotlin.Int?) : ApiResponse<CreatePreventiveMaintenanceParentDtoListResultDto?> {
        val localVariableConfig = apiServicesAppGmaoGetPreventiveMaintenancesGetRequestConfig(status = status, skipCount = skipCount, maxResultCount = maxResultCount)

        return request<Unit, CreatePreventiveMaintenanceParentDtoListResultDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoGetPreventiveMaintenancesGet
    *
    * @param status  (optional)
    * @param skipCount  (optional)
    * @param maxResultCount  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoGetPreventiveMaintenancesGetRequestConfig(status: PreventiveMaintenanceStatus?, skipCount: kotlin.Int?, maxResultCount: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (status != null) {
                    put("Status", listOf(status.toString()))
                }
                if (skipCount != null) {
                    put("SkipCount", listOf(skipCount.toString()))
                }
                if (maxResultCount != null) {
                    put("MaxResultCount", listOf(maxResultCount.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/services/app/Gmao/GetPreventiveMaintenances",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param preventiveMaintenanceId  (optional)
    * @param nextFiringTime  (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoSetPreventiveMaintenanceConfigNextFiringDatePost(preventiveMaintenanceId: kotlin.Int?, nextFiringTime: java.time.OffsetDateTime?) : Unit {
        val localVarResponse = apiServicesAppGmaoSetPreventiveMaintenanceConfigNextFiringDatePostWithHttpInfo(preventiveMaintenanceId = preventiveMaintenanceId, nextFiringTime = nextFiringTime)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param preventiveMaintenanceId  (optional)
    * @param nextFiringTime  (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoSetPreventiveMaintenanceConfigNextFiringDatePostWithHttpInfo(preventiveMaintenanceId: kotlin.Int?, nextFiringTime: java.time.OffsetDateTime?) : ApiResponse<Unit?> {
        val localVariableConfig = apiServicesAppGmaoSetPreventiveMaintenanceConfigNextFiringDatePostRequestConfig(preventiveMaintenanceId = preventiveMaintenanceId, nextFiringTime = nextFiringTime)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoSetPreventiveMaintenanceConfigNextFiringDatePost
    *
    * @param preventiveMaintenanceId  (optional)
    * @param nextFiringTime  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoSetPreventiveMaintenanceConfigNextFiringDatePostRequestConfig(preventiveMaintenanceId: kotlin.Int?, nextFiringTime: java.time.OffsetDateTime?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (preventiveMaintenanceId != null) {
                    put("preventiveMaintenanceId", listOf(preventiveMaintenanceId.toString()))
                }
                if (nextFiringTime != null) {
                    put("nextFiringTime", listOf(parseDateToQueryString(nextFiringTime)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/Gmao/SetPreventiveMaintenanceConfigNextFiringDate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param uploadFileDto  (optional)
    * @return UploadFileResponseDto
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiServicesAppGmaoUploadFilePost(uploadFileDto: UploadFileDto?) : UploadFileResponseDto {
        val localVarResponse = apiServicesAppGmaoUploadFilePostWithHttpInfo(uploadFileDto = uploadFileDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UploadFileResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param uploadFileDto  (optional)
    * @return ApiResponse<UploadFileResponseDto?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiServicesAppGmaoUploadFilePostWithHttpInfo(uploadFileDto: UploadFileDto?) : ApiResponse<UploadFileResponseDto?> {
        val localVariableConfig = apiServicesAppGmaoUploadFilePostRequestConfig(uploadFileDto = uploadFileDto)

        return request<UploadFileDto, UploadFileResponseDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation apiServicesAppGmaoUploadFilePost
    *
    * @param uploadFileDto  (optional)
    * @return RequestConfig
    */
    fun apiServicesAppGmaoUploadFilePostRequestConfig(uploadFileDto: UploadFileDto?) : RequestConfig<UploadFileDto> {
        val localVariableBody = uploadFileDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json-patch+json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/services/app/Gmao/UploadFile",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
